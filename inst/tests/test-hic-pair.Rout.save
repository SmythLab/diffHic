
R version 3.3.0 Patched (2016-05-03 r70580) -- "Supposedly Educational"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ###################################################################################################
> # This script is designed to test the pair-identifying capabilities of the hiC machinery i.e. preparePairs. 
> # We start with unit tests for individual components of the preparePairs C++ code.
> 
> suppressWarnings(suppressPackageStartupMessages(require(diffHic)))
> source("simsam.R")
> 
> dir<-"hic-test"
> dir.create(dir)
> 
> # Checking CIGAR.
> 
> checkCIGAR <- function(cigar, rstrand) {
+     output <- simsam(file.path(dir, "whee"), "chrA", 1, !rstrand, c("chrA"=1000), 
+            cigar=cigar, len=GenomicAlignments::cigarWidthAlongQuerySpace(cigar))
+ 
+ 	out <- .Call(diffHic:::cxx_test_parse_cigar, output)
+ 	if (is.character(out)) { stop(out) }
+ 	
+ 	true.alen <- GenomicAlignments::cigarWidthAlongReferenceSpace(cigar)
+ 	if (out[1]!=true.alen) { stop("mismatch in alignment length") }
+ 
+ 	offset <- 0
+ 	as.rle <- GenomicAlignments::cigarToRleList(cigar)[[1]]
+ 	if (rstrand) { as.rle <- rev(as.rle) }
+ 	if (runValue(as.rle)[1]=="H") { offset <- runLength(as.rle)[1] } 
+ 	if (out[2]!=offset) { stop("mismatch in offsets") }
+ 
+ 	return(c(alen=true.alen, offset=offset))
+ }
> 
> checkCIGAR("5H20M", TRUE)
Loading required package: Rsamtools
Loading required package: Biostrings
Loading required package: XVector
  alen offset 
    20      0 
> checkCIGAR("5H20M", FALSE)
  alen offset 
    20      5 
> 
> checkCIGAR("5H20M6H", TRUE)
  alen offset 
    20      6 
> checkCIGAR("5H20M6H", FALSE)
  alen offset 
    20      5 
> 
> checkCIGAR("5H20M6S", TRUE)
  alen offset 
    20      0 
> checkCIGAR("5H20M6S", FALSE)
  alen offset 
    20      5 
> 
> checkCIGAR("20M5I30M", TRUE)
  alen offset 
    50      0 
> checkCIGAR("20M5D30M", TRUE)
  alen offset 
    55      0 
> checkCIGAR("20M5N30M", TRUE)
  alen offset 
    55      0 
> checkCIGAR("20M5P30M", TRUE)
  alen offset 
    50      0 
> 
> checkCIGAR("20M5X30M", TRUE)
  alen offset 
    55      0 
> checkCIGAR("20M5=30M", TRUE)
  alen offset 
    55      0 
> 
> checkCIGAR("10M2I5M3D20M", TRUE)
  alen offset 
    38      0 
> checkCIGAR("10M2I3D5N20M", TRUE)
  alen offset 
    38      0 
> checkCIGAR("10M2P5M3D20I", TRUE)
  alen offset 
    18      0 
> checkCIGAR("10M2I3D5N20D", TRUE)
  alen offset 
    38      0 
> 
> checkCIGAR("5H11M5D8I9X6=6H", TRUE)
  alen offset 
    31      6 
> checkCIGAR("5H20X5D8P9N72M", FALSE)
  alen offset 
   106      5 
> checkCIGAR("5S19M34=55D8X20M6S", TRUE)
  alen offset 
   136      0 
> checkCIGAR("5S1M3=5D18X2M6S", FALSE)
  alen offset 
    29      0 
> 
> # Checking fragment assignment.
> 
> assign2fragment <- function(starts, ends, chr, pos, rstrand, len) {
+ 	out <- .Call(diffHic:::cxx_test_fragment_assign, starts, ends, chr, pos, rstrand, len)
+ 	if (is.character(out)) { stop(out) }
+ 
+ 	chr <- chr + 1L
+ 	if (rstrand) { 
+ 		fiveprime <- min(pos + len -1L, tail(ends[[chr]], 1))
+ 		stopifnot(ends[[chr]][out] >= fiveprime && (out==1L || ends[[chr]][out-1] < fiveprime))
+ 	} else { 
+ 		fiveprime <- pos 
+ 		stopifnot(starts[[chr]][out] <= fiveprime && (out==length(starts[[chr]]) || starts[[chr]][out+1] > fiveprime))
+ 	}
+ 	
+ 	out
+ }
> 
> starts <- list( c(1L, 100L, 200L, 300L, 400L, 500L), # chr1
+                 c(1L, 100L, 200L, 300L, 400L, 500L)) # chr2
> ends <- list( c(103L, 203L, 303L, 403L, 503L, 1000L), # chr1
+               c(103L, 203L, 303L, 403L, 503L, 1000L)) # chr2
> 
> assign2fragment(starts, ends, 0L, 94L, TRUE, 10L)
[1] 1
> assign2fragment(starts, ends, 0L, 95L, TRUE, 10L)
[1] 2
> assign2fragment(starts, ends, 0L, 99L, FALSE, 10L)
[1] 1
> assign2fragment(starts, ends, 0L, 100L, FALSE, 10L)
[1] 2
> 
> assign2fragment(starts, ends, 0L, 203L, TRUE, 1L)
[1] 2
> assign2fragment(starts, ends, 0L, 204L, TRUE, 1L)
[1] 3
> assign2fragment(starts, ends, 0L, 209L, FALSE, 1L)
[1] 3
> assign2fragment(starts, ends, 0L, 300L, FALSE, 1L)
[1] 4
> 
> assign2fragment(starts, ends, 1L, 1L, FALSE, 10L)
[1] 1
> assign2fragment(starts, ends, 1L, 991L, FALSE, 10L)
[1] 6
> assign2fragment(starts, ends, 1L, 992L, FALSE, 10L)
[1] 6
> assign2fragment(starts, ends, 1L, 991L, TRUE, 10L)
[1] 6
> assign2fragment(starts, ends, 1L, 992L, TRUE, 10L)
[1] 6
Warning message:
In assign2fragment(starts, ends, 1L, 992L, TRUE, 10L) :
  read aligned off end of chromosome
> 
> starts <- list( c(1L, 1L, 100L, 200L, 300L, 400L, 500L, 997L), # chr1, with nesting at the start and end.
+                 c(1L, 1L, 100L, 200L, 300L, 400L, 500L, 997L)) # chr2
> ends <- list( c(4L, 103L, 203L, 303L, 403L, 503L, 1000L, 1000L), # chr1
+               c(4L, 103L, 203L, 303L, 403L, 503L, 1000L, 1000L)) # chr2
> 
> assign2fragment(starts, ends, 0L, 1L, FALSE, 10L)
[1] 2
> assign2fragment(starts, ends, 0L, 1L, TRUE, 10L)
[1] 2
> assign2fragment(starts, ends, 0L, 991L, FALSE, 10L)
[1] 7
> assign2fragment(starts, ends, 0L, 991L, TRUE, 10L)
[1] 7
> try(assign2fragment(starts, ends, 0L, 1000L, TRUE, 10L)) # This should fail, as it gets assigned into the nested fragment.
Error : ends[[chr]][out] >= fiveprime && (out == 1L || ends[[chr]][out -  .... is not TRUE
In addition: Warning message:
In assign2fragment(starts, ends, 0L, 1000L, TRUE, 10L) :
  read aligned off end of chromosome
> 
> ###################################################################################################
> # We also set up a full simulation for the entire function.
> 
> suppressPackageStartupMessages(require("rhdf5"))
> 
> comp<-function (fname, npairs, max.cuts, sizes=c(100, 500), singles=0, rlen=10, spacer=rlen, pseudo=FALSE, extras=NULL) {
+ 	rlen<-as.integer(rlen)
+ 	spacer<-as.integer(spacer)
+ 	if (min(sizes) <= rlen) { stop("min fragment must be greater than read length") } 
+ 	# Necessary for proper assignment, especially at the start of the chromosome when reverse 
+ 	# reads are bounded at zero (i.e. their 5' ends would not be defined if 1+rlen > fragmentsize)
+ 
+ 	if (pseudo) {
+ 		stopifnot(sizes[1]==sizes[2])
+ 		stopifnot(spacer == 0L)
+ 	}
+ 
+ 	# Randomly generating fragment lengths for the chromosome.
+ 	fragments<-list()
+ 	cut.starts<-list()
+ 	chromosomes<-rep(0L, length(max.cuts));
+ 	outfrags<-list()
+ 	for (i in 1:length(max.cuts)) { 
+ 		fragments[[i]]<-as.integer(round(runif(max.cuts[[i]], sizes[1], sizes[2])))
+ 		ends<-cumsum(fragments[[i]])+1:max.cuts[[i]]*spacer
+ 		if (max.cuts[[i]]>1) { 
+ 			cut.starts[[i]]<-c(1L, (ends+1L)[1:(max.cuts[[i]]-1)])
+ 		} else {
+ 			cut.starts[[i]]<-1L
+ 		}
+ 		outfrags[[i]]<-GRanges(names(max.cuts)[i], IRanges(cut.starts[[i]], ends-spacer))
+ 		chromosomes[i]<-tail(ends, 1)-spacer;
+ 	}
+     if (!is.null(extras)) { # Editing it for error-checking purposes.
+         if (extras[1]==-1L) {
+             outfrags <- outfrags[-1]
+         } else {
+             outfrags <- c(outfrags, list(GRanges(extras, IRanges(1, sizes[1]))))
+         }
+     }
+ 	suppressWarnings(outfrags<-do.call(c, outfrags))
+ 	names(chromosomes)<-names(max.cuts)
+ 	names(fragments)<-names(max.cuts)
+ 	names(cut.starts)<-names(max.cuts)
+ 
+ 	# Randomly generating reads (a la getPETSizes' example).
+     names<-paste('x', rep(1:npairs, 2), sep=".");
+     chrs<-sample(length(chromosomes), length(names), replace=TRUE);
+     pos<-integer(length(names));
+ 	frag.ids<-integer(length(names))
+     str<-rbinom(length(names), 1, 0.5)==1; 
+ 
+     # Assigning positions to all of them. Some finesse is necessary when 
+ 	# there is no spacer (i.e. original genome with positive overhang). We
+ 	# still allow reads to span restriction sites, though.
+     for (i in 1:length(chromosomes)) {
+         current<-chrs==i;
+ 		chosen.frags<-as.integer(runif(sum(current), 1, length(fragments[[i]]))+0.5)
+ 		frag.ids[current]<-chosen.frags
+ 		my.ends <- cut.starts[[i]] + fragments[[i]]
+ 		if (spacer > 0) {
+ 			pos[current]<-as.integer(runif(sum(current), cut.starts[[i]][chosen.frags], my.ends[chosen.frags]-rlen))
+ 		} else {
+ 			cur.for <- str[current]
+ 			forward.frag <- chosen.frags[cur.for]
+ 			pos[current][cur.for] <- as.integer(runif(sum(cur.for), 
+ 					cut.starts[[i]][forward.frag],
+ 					ifelse(forward.frag!=length(cut.starts[[i]]),
+ 						cut.starts[[i]][forward.frag+1L],
+ 						my.ends[forward.frag])))
+ 			# Note that as.integer(runif(1, a, b)) samples from [a, b), as runif() will never actually generate 'b'.
+ 			# So, this will only generate positions after and including the start position for the chosen fragment,
+ 			# but before and not including the start position for the next fragment (or 1-past the end of the chromosome).
+ 			
+ 			reverse.frag <- chosen.frags[!cur.for]
+ 			starter <- integer(sum(!cur.for))
+ 			possible.zero <- reverse.frag==1L
+ 			starter[possible.zero] <- 1L
+ 			starter[!possible.zero] <- my.ends[reverse.frag[!possible.zero]-1L] 
+ 			pos[current][!cur.for] <- pmax(1L, 
+ 				as.integer(runif(sum(!cur.for), starter, my.ends[chosen.frags[!cur.for]])) - rlen + 1L)
+ 			# Recall that the 'ends' are 1-past the last base of the fragment, so this runif() will sample from 
+ 			# the first non-overlapping base of the current fragment to the last base of the current fragment
+ 			# (it's [a, b), so when b is 1-past the last base, sampling will include the last base).
+ 		}
+     }
+ 
+     # Throwing them into the SAM file generator. Note that chromosome names are ordered inside. 
+     # If this differs from the order in 'max.cuts', it will test the ability of preparePairs to match them up correctly.
+ 	reversi<-c(1:npairs+npairs, 1:npairs)
+     out<-simsam(fname, names(chromosomes)[chrs], pos, str, chromosomes[order(names(chromosomes))], names=names, len=rlen, 
+ 			is.first=c(rep(TRUE, npairs), rep(FALSE, npairs)), is.paired=TRUE,
+ 			mate.chr=names(chromosomes)[chrs][reversi], mate.pos=pos[reversi], mate.str=str[reversi])
+ 
+ 	if (singles) { 
+ 	    # Adding some singles. You'll get some warnings regarding spacer regions as we're not finessing it.
+     	snames<-schrs<-spos<-NULL
+         snames<-paste('y', 1:singles, sep=".");
+         schrs<-sample(length(chromosomes), singles, replace=TRUE);
+         spos<-integer(singles);
+ 		for (i in 1:length(chromosomes)) {
+ 	       	scurrent<-schrs==i;
+         	spos[scurrent]<-as.integer(round(runif(sum(scurrent), 1, chromosomes[i])))
+ 		}
+ 	
+     	tempname<-file.path(dir, "temp")
+     	sstr<-rbinom(singles, 1, 0.5)==1; 
+ 		out2<-simsam(tempname, names(chromosomes)[schrs], spos, sstr, chromosomes, names=snames, len=rlen)
+ 		more.temp<-file.path(dir, "temp2")
+ 		out<-mergeBam(c(out, out2), more.temp, indexDestination=TRUE, overwrite=TRUE)
+ 		file.rename(more.temp, out)
+ 	}
+ 
+ 	# Resorting by name.
+ 	temp<-sortBam(out, "temp", byQname=TRUE)
+ 	file.rename(temp, out)
+ 
+ 	################ THEORETICAL MATCH ###################
+ 
+ 	# This gets the status: 0 for okay, 1 for dangling end, 3 for self.circles and and 2 for other stuff.
+ 	getstatus <- function(chr1, pos1, frag1, str1, chr2, pos2, frag2, str2) {
+ 		codes<-rep(0L, length(chr1));
+ 		potentials<-chr1==chr2 & frag1==frag2
+ 		
+ 		same.str<-str1==str2;
+ 		codes[ same.str & potentials ] <- 2L;
+ 		potentials <- potentials & !same.str;
+ 		
+ 		self.circle<-(str1 & pos2+rlen <= pos1) | (str2 & pos1+rlen <= pos2);
+ 		codes[ self.circle & potentials ] <- 3L
+ 		potentials<-potentials & !self.circle
+ 		
+ 		overextension<-(str1 & pos1 > pos2) | (str2 & pos2 > pos1) # Don't need to check +rlen, as they're al the same.
+ 		codes[ overextension & potentials ]<- 2L;
+ 		potentials<-potentials & !overextension;
+ 		
+ 		codes[potentials] <- 1L;
+ 		return(codes);
+ 	}
+ 
+ 	# This gets the distance from the 5' end of the read to the next restriction site that it is pointing to (past the one it covers, if it is incomplete).
+ 	getlen <- function(chr, pos, start, str) {
+ 		len.out<-rep(0L, length(chr));
+ 		for (x in 1:length(cut.starts)) { 
+ 			chosen<-x==chr;
+ 			dist2cut<-ifelse(str[chosen], cut.starts[[x]][start[chosen]]+fragments[[x]][start[chosen]]-pos[chosen],
+ 					pos[chosen]+rlen-cut.starts[[x]][start[chosen]])
+ 			len.out[chosen]<-dist2cut;
+ 		}
+ 		return(len.out);
+ 	}	
+ 
+ 	# Now, actually assembling the theoretical values.
+ 	primary<-1:npairs
+ 	secondary<-npairs+1:npairs
+ 	pchrs<-chrs[primary]
+ 	ppos<-pos[primary]
+ 	pfrag<-frag.ids[primary]
+ 	pstr<-str[primary]
+ 	schrs<-chrs[secondary]
+ 	spos<-pos[secondary]
+ 	sfrag<-frag.ids[secondary]
+ 	sstr<-str[secondary]
+ 	codes<-getstatus(pchrs, ppos, pfrag, pstr, schrs, spos, sfrag, sstr)
+ 	frag.lens<-getlen(pchrs, ppos, pfrag, pstr)+getlen(schrs, spos, sfrag, sstr)
+ 	panchor <- pchrs > schrs | 
+ 		(pchrs==schrs & pfrag > sfrag) | 
+ 		(pchrs==schrs & pfrag==sfrag & ppos > spos)
+ 	inserts<-ifelse(pchrs==schrs, pmax(ppos, spos)-pmin(spos, ppos)+rlen, NA)
+ 	orientations<-ifelse(pstr, 0L, ifelse(panchor, 1L, 2L))+ifelse(sstr, 0L, ifelse(panchor, 2L, 1L))
+ 
+ 	################ ACTUAL MATCH ###################
+ 	# Assembling the output list for comparison.
+ 
+ 	tmpdir<-paste0(fname, "_temp")
+ 	param <- pairParam(fragments=outfrags)
+ 	if (pseudo) {
+ 		# Special behaviour; faster assignment into bins, no removal of dangling ends/self-cirlces
+ 		# (as these concepts are meaningless for arbitrary bins).
+ 		diagnostics <- prepPseudoPairs(out, param, tmpdir, output.dir=file.path(dir, "whee"))
+ 	} else {
+ 		diagnostics <- preparePairs(out, param, tmpdir, output.dir=file.path(dir, "whee"))
+ 		
+ 		stopifnot(sum(codes==1L)==diagnostics$same.id[["dangling"]])
+ 		stopifnot(sum(codes==3L)==diagnostics$same.id[["self.circle"]])
+ 		stopifnot(length(codes)==diagnostics$pairs[["total"]])
+ 		stopifnot(singles==diagnostics$singles)
+ 
+ 		# No support for testing chimeras, we use a fixed example below.
+ 		stopifnot(diagnostics$unmapped.chimeras==0L) 
+ 		stopifnot(diagnostics$chimeras[["total"]]==0L)
+ 		stopifnot(diagnostics$chimeras[["mapped"]]==0L)
+ 		stopifnot(diagnostics$chimeras[["invalid"]]==0L)
+ 	}
+ 
+ 	# Anchor1/anchor2 synchronisation is determined by order in 'fragments' (and thusly, in max.cuts).
+ 	offset<-c(0L, cumsum(max.cuts))
+ 	names(offset)<-NULL
+ 	indices<-diffHic:::.loadIndices(tmpdir, seqlevels(outfrags))
+ 	used<-indices
+ 	fchrs<-as.character(seqnames(outfrags))
+ 
+ 	for (i in 1:length(max.cuts)) {
+ 		for (j in 1:i) {
+ 			stuff<-(chrs[primary]==i & chrs[secondary]==j) | (chrs[primary]==j & chrs[secondary]==i) 
+ 			if (!pseudo) { stuff<-stuff & (codes==0L | codes==2L) }
+ 			pids<-frag.ids[primary][stuff];
+ 			sids<-frag.ids[secondary][stuff];
+ 			if (i > j) {
+ 				which.is.which<-chrs[primary][stuff]==i & chrs[secondary][stuff]==j
+  			    anchor1<-ifelse(which.is.which, pids, sids)
+ 				anchor2<-ifelse(which.is.which, sids, pids)
+ 			} else {
+ 				anchor1<-pmax(pids, sids)
+ 				anchor2<-pmin(pids, sids)
+ 			}
+ 			anchor1<-anchor1+offset[i]
+ 			anchor2<-anchor2+offset[j]
+ 			totes<-frag.lens[stuff]
+ 			cur.ori<-orientations[stuff]
+ 			cur.insert<-inserts[stuff]
+ 			o<-order(anchor1, anchor2, totes, cur.ori, cur.insert)
+ 
+ 			# Checking anchor1/anchor2/length/orientation/insert statistics (sorting to ensure comparability).
+ 			achr<-names(max.cuts)[i]
+ 			tchr<-names(max.cuts)[j]
+ 			if (!(achr%in%names(indices)) || !(tchr %in% names(indices[[achr]]))) { 
+ 				if (length(o)) { stop("true interactions are missing") }
+ 				next
+ 			}
+ 			current<-h5read(tmpdir, file.path(achr, tchr))
+ 			for (x in 1:ncol(current)) { attributes(current[,x]) <- NULL }
+ 			collated <- diffHic:::.getStats(current, achr==tchr, outfrags)
+ 			
+ 			o2 <- order(current$anchor1.id, current$anchor2.id, collated$length, collated$orientation, collated$insert)
+ 			stopifnot(identical(current$anchor1.id[o2], anchor1[o]))
+ 			stopifnot(identical(current$anchor2.id[o2], anchor2[o]))
+ 			stopifnot(identical(collated$length[o2], totes[o]))
+ 			stopifnot(identical(collated$orientation[o2], cur.ori[o]))
+ 			if (!identical(collated$insert[o2], cur.insert[o])) { 
+ 				print(cbind(collated$insert[o2], cur.insert[o]))
+ 				print(current[o2,])
+ 			}
+ 			stopifnot(identical(collated$insert[o2], cur.insert[o]))
+ 				
+ 			# Checking that we're looking at the right combination.
+ 	        uniq.a<-unique(fchrs[current[,1]])
+ 			uniq.t<-unique(fchrs[current[,2]])
+ 			if (length(uniq.a)!=1L || length(uniq.t)!=1L) { stop("file contains more than one combination") }
+ 			if (achr!=uniq.a || tchr!=uniq.t) { stop("file contains the incorrect combination") }
+ 			used[[achr]][[tchr]]<-NULL
+ 		}
+ 	}
+ 
+ 	# Checking there's nothing left.
+ 	if (!is.null(unlist(used))) { stop("objects left unused in the directory") }
+ 
+ 	# Length insert and orientation checking.
+ 	if (!pseudo) { 
+ 		keepers<-codes==0L | codes==2L
+ 	} else { 
+ 		keepers <- !logical(length(codes)) 
+ 	}
+ 	valid.len<-frag.lens[keepers]
+ 	valid.insert<-inserts[keepers]
+ 	valid.ori<-orientations[keepers]
+ 	o<-order(valid.len, valid.ori, valid.insert)
+ 	auxiliary<-getPairData(tmpdir, param)
+ 	o2<-do.call(order, auxiliary)
+ 	if (!identical(valid.len[o], auxiliary$length[o2])) { stop("extracted fragment sizes don't match up") }
+ 	if (!identical(valid.insert[o], auxiliary$insert[o2])) { stop("extracted inserts don't match up") }
+ 	if (!identical(valid.ori[o], auxiliary$orientation[o2])) { stop("extracted orientations don't match up") }
+ 
+ 	curdex <- h5ls(tmpdir)
+ 	curdex <- curdex[curdex$otype=="H5I_DATASET",][1,]
+ 	returned <- h5read(tmpdir, file.path(curdex$group, curdex$name))
+ 	processed <- diffHic:::.getStats(returned, basename(curdex$group)==curdex$name, outfrags)
+ 	return(head(data.frame(anchor1.id=returned$anchor1.id, anchor2.id=returned$anchor2.id, length=processed$length,
+ 		orientation=processed$orientation, insert=processed$insert)))
+ }
> 
> ####################################################################################################
> # Initiating testing with something fairly benign.
> 
> set.seed(0)
> fname<-file.path(dir, "out");
> max.cuts<-c(chrA=20L, chrB=10L, chrC=5L)
> 
> comp(fname, npairs=20, max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1         23          1    344           1     NA
2         26          4    274           3     NA
3         26         10    400           1     NA
4         26         20    247           2     NA
5         29         15    240           1     NA
> comp(fname, npairs=50, max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1         11          2    219           3   2404
2         11         10    122           0    276
3         16          1    206           2   4188
4         18          4    440           3   3942
5         19         13    174           2   2003
6         19         15    262           3   1339
> comp(fname, npairs=100, max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1          7          1    392           0   2253
2          8          5    186           2    941
3         14          5    336           3   2769
4         15         10    173           2   1977
5         16         10    309           2   2268
6         18          7     64           3   3310
> 
> # Ramping up the aggression in terms of self-circles.
> 
> comp(fname, npairs=20, max.cuts=c(chrA=3L))
  anchor1.id anchor2.id length orientation insert
1          2          1    195           1    205
2          2          1    174           3    292
3          2          1    197           2    211
4          2          2    296           0    102
5          2          2    241           0    163
6          3          1    256           1    496
> comp(fname, npairs=50, max.cuts=c(chrA=3L))
  anchor1.id anchor2.id length orientation insert
1          1          1    305           0     63
2          2          1    500           2    267
3          2          1    148           3    400
4          2          1    154           2    613
5          2          1    222           3    486
6          2          1    218           0    413
> comp(fname, npairs=100, max.cuts=c(chrA=3L))
  anchor1.id anchor2.id length orientation insert
1          1          1    352           0     98
2          1          1    156           0    130
3          1          1    180           3    152
4          2          1     96           3    274
5          2          1    275           3     81
6          2          1     92           1    102
> 
> # Increasing the number of reads all round.
> 
> comp(fname, npairs=200, size=c(500, 1000), max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          7          2    944           1   4648
2          8          2   1077           2   5353
3          8          6    612           1   1479
4          8          7     52           0    946
5          9          6    504           2   2993
6         10          6    891           0   3007
> comp(fname, npairs=1000, size=c(500, 1000), max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          2          2    423           3    107
2          3          2   1022           0    442
3          6          1    668           0   3980
4          6          1    655           3   4426
5          6          4    687           0   2194
6          6          4    760           1   1653
> 
> # Adding some singletons.
> 
> comp(fname, npairs=200, size=c(20, 100), max.cuts=max.cuts, singles=10)
  anchor1.id anchor2.id length orientation insert
1          5          3     75           3    137
2          7          3     57           1    252
3          9          5     36           0    253
4          9          5     56           3    224
5          9          5     64           1    248
6         12          6     51           1    419
> comp(fname, npairs=200, size=c(20, 100), max.cuts=max.cuts, singles=50)
  anchor1.id anchor2.id length orientation insert
1          7          5     44           3    116
2          9          8     26           0     81
3         10          3     71           2    468
4         11          4     63           2    481
5         12          1     37           2    806
6         12          1     55           0    784
> 
> # Making the fragments smaller.
> 
> comp(fname, npairs=200, size=c(60, 100), rlen=50, max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1          4          3    132           2    184
2          5          4    148           2    185
3          8          5    130           2    419
4          9          4    129           1    678
5          9          7    118           2    305
6          9          9    108           2     83
> comp(fname, npairs=500, size=c(60, 100), rlen=50, max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1          2          1    136           2    197
2          6          2    125           1    571
3          6          3    115           2    454
4          8          7    121           1    171
5          9          2    142           1    974
6          9          5    124           0    548
> 
> # Trying out negative spacings (i.e., non-filled genomes)
> 
> comp(fname, npairs=200, size=c(500, 1000), spacer=-2, max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          4          3    470           3   1020
2          6          3    453           0   2313
3          7          1   1266           3   4733
4          7          3    935           2   3098
5          7          3    185           2   3848
6          8          2    627           0   4399
> comp(fname, npairs=1000, size=c(500, 1000), spacer=-2, max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          2          2    734           0    312
2          3          2   1044           2    538
3          4          2    375           2   1838
4          4          3    998           3    544
5          5          4     40           0    592
6          6          2   1071           2   2287
> comp(fname, npairs=200, size=c(500, 1000), spacer=-4, max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          2          2    644           2     19
2          6          5    625           0    582
3          6          5    672           0    893
4          9          4   1046           1   3885
5          9          5    988           0   2417
6         11          3   1669           0   6388
> comp(fname, npairs=1000, size=c(500, 1000), spacer=-4, max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          3          1   1037           2   1267
2          5          4    327           1    323
3          5          4    676           1    672
4          6          3   1309           3   2374
5          6          6    841           0    259
6          7          1    483           3   4855
> 
> comp(fname, npairs=200, size=c(20, 100), spacer=-2, max.cuts=max.cuts, singles=10)
  anchor1.id anchor2.id length orientation insert
1          3          1     65           2    161
2          5          2     99           2    229
3          7          3     68           1    317
4          7          3     62           1    311
5          9          3     64           3    443
6          9          4     39           1    342
> comp(fname, npairs=200, size=c(20, 100), spacer=-2, max.cuts=max.cuts, singles=50)
  anchor1.id anchor2.id length orientation insert
1          2          1     53           0     35
2          6          5    106           1    104
3          8          4     56           0    244
4          8          8     25           3     27
5         11          1     41           1    527
6         12          8     72           2    234
> comp(fname, npairs=200, size=c(20, 100), spacer=-4, max.cuts=max.cuts, singles=10)
  anchor1.id anchor2.id length orientation insert
1          7          2     85           3    351
2          7          2     54           1    288
3          8          1    100           0    428
4          9          2     38           2    461
5         10          2     45           1    472
6         10          7     90           0    183
> comp(fname, npairs=200, size=c(20, 100), spacer=-4, max.cuts=max.cuts, singles=50)
  anchor1.id anchor2.id length orientation insert
1          3          3     23           0     13
2          5          2     24           0    154
3          6          2    110           1    242
4          8          5     22           0    194
5         10          3     45           3    424
6         12          2     47           2    595
> 
> comp(fname, npairs=200, size=c(60, 100), spacer=-4, rlen=50, max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1          6          3     82           3    286
2          6          4    115           2    251
3          6          5     77           0    137
4          7          4     99           2    357
5          8          4     50           1    310
6          9          2     42           2    699
> comp(fname, npairs=500, size=c(60, 100), spacer=-4, rlen=50, max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1          3          2    138           3    105
2          7          3     87           1    353
3          8          2     37           2    655
4          9          1     55           0    683
5          9          2    123           3    627
6          9          7     35           1    122
> comp(fname, npairs=200, size=c(60, 100), spacer=-2, rlen=50, max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1          2          1    135           3    132
2          4          1     71           3    233
3         10          4    133           2    526
4         10          5    114           1    436
5         12          4     71           1    625
6         12          4     26           3    682
> comp(fname, npairs=500, size=c(60, 100), spacer=-2, rlen=50, max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1          5          2     74           3    265
2          5          4     76           3     93
3          6          1     74           2    450
4          7          4     74           1    203
5          8          3     51           1    338
6          9          2     31           1    470
> 
> # Trying it out with some more elements in a more restricted space.
> 
> comp(fname, npairs=500, size=c(100, 500), max.cuts=c(chrA=2L))
  anchor1.id anchor2.id length orientation insert
1          1          1    598           3    152
2          1          1    176           0     96
3          1          1    688           0     38
4          1          1    318           3    224
5          1          1    428           0    132
6          1          1    830           0     82
> comp(fname, npairs=200, size=c(500, 1000), max.cuts=c(chrA=2L, chrB=1L))
  anchor1.id anchor2.id length orientation insert
1          1          1    836           0    316
2          1          1    882           3    346
3          1          1    937           0    357
4          1          1   1104           3    180
5          1          1    628           0    104
6          1          1    645           2     19
> comp(fname, npairs=1000, size=c(20, 50), max.cuts=c(chrA=1L))
  anchor1.id anchor2.id length orientation insert
1          1          1     70           0     16
2          1          1     59           0     27
3          1          1     70           3     34
4          1          1     69           3     25
5          1          1     49           0     21
6          1          1     52           2     16
> 
> # Adding lots of chromosomes.
> 
> max.cuts<-c(chrA=5L, chrB=6L, chrC=7L, chrD=4L, chrE=3L, chrF=1L, chrG=2L)
> comp(fname, npairs=200, size=c(500, 1000), max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          2          1    879           3    853
2          3          1   1105           0   1200
3          3          2    442           2    867
4          5          4    863           1    873
> comp(fname, npairs=1000, size=c(50, 100), max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          2          1     95           3    128
2          3          1     38           0    187
3          3          1     68           0    201
4          3          2     79           2     98
5          3          2     83           2     94
6          3          2     75           0    123
> comp(fname, npairs=200, size=c(100, 500), max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          4          4    139           0     41
2          5          2    493           2    712
> comp(fname, npairs=1000, size=c(200, 300), max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1          2          1    150           1    160
2          2          1    394           0    396
3          3          1    315           2    469
4          3          3    146           3    108
5          4          1     73           3    793
6          4          1    160           0    726
> 
> max.cuts<-c(chrD=5L, chrC=6L, chrA=7L, chrE=4L, chrG=3L, chrB=1L, chrF=2L) # Shuffled, to test effect of non-trivial 'm'.
> comp(fname, npairs=200, size=c(500, 1000), max.cuts=max.cuts)
  anchor1.id anchor2.id length orientation insert
1         16         12    851           0   3432
2         16         13    369           0   2622
3         16         14    963           3   2315
> comp(fname, npairs=1000, size=c(50, 100), max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1         13         12     89           3     76
2         14         13    146           2     49
3         15         12     73           3    269
4         15         14     66           1     76
5         15         14     86           2     71
6         16         15     85           2     63
> comp(fname, npairs=200, size=c(100, 500), max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1         17         16    129           3    583
2         17         17    179           0     39
3         18         16    733           0    765
> comp(fname, npairs=1000, size=c(200, 300), max.cuts=max.cuts);
  anchor1.id anchor2.id length orientation insert
1         12         12    144           3     40
2         14         13    293           3    376
3         15         13    251           3    333
4         15         13    263           0    645
5         16         12    167           2   1107
6         16         13    367           3    792
> 
> # Checking results with pseudo-ness
> 
> max.cuts<-c(chrA=20L, chrB=10L, chrC=5L)
> comp(fname, npairs=20, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(100, 100))
  anchor1.id anchor2.id length orientation insert
1         12          1    149           0   1097
2         14          1    109           0   1283
3         16         15    116           0     76
4         18          7    128           1   1128
5         20          5    175           3   1509
> comp(fname, npairs=50, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(100, 100))
  anchor1.id anchor2.id length orientation insert
1         12          6     75           1    575
2         15          9     58           1    558
3         18         10     86           3    750
> comp(fname, npairs=100, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(100, 100))
  anchor1.id anchor2.id length orientation insert
1          3          2     51           1     51
2          4          2    160           2    160
3          8          2     99           3    545
4         10          5    183           1    583
5         11          8     97           1    297
6         12          9     44           0    296
> comp(fname, npairs=100, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(200, 200))
  anchor1.id anchor2.id length orientation insert
1          4          2    179           1    379
2         12         11     47           1     47
3         14          6    229           0   1577
4         14          8    265           3   1319
5         17          7    298           1   2098
6         17         13     48           1    648
> comp(fname, npairs=1000, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(500, 500))
  anchor1.id anchor2.id length orientation insert
1          2          2    533           3    289
2          3          1    626           1   1126
3          4          3    670           0    342
4          4          3     36           0    522
5          5          2    492           3   1368
6          5          5    838           0     70
> 
> max.cuts<-c(chrB=20L, chrC=10L, chrA=5L) # Shuffled
> comp(fname, npairs=20, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(100, 100))
  anchor1.id anchor2.id length orientation insert
1         34         32    108           3    238
2         34         32    190           1    290
> comp(fname, npairs=50, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(100, 100))
  anchor1.id anchor2.id length orientation insert
1         32         32    129           0     79
2         32         32     76           2     44
3         33         32    152           3     64
4         34         32     51           0    203
5         35         32     45           1    245
6         35         32    105           2    315
> comp(fname, npairs=100, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(100, 100))
  anchor1.id anchor2.id length orientation insert
1         32         32     77           2     43
2         33         31     52           2    268
3         33         31    106           1    206
4         33         32    177           2     43
5         33         33    114           1     14
6         34         31     76           3    258
> comp(fname, npairs=100, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(200, 200))
  anchor1.id anchor2.id length orientation insert
1         32         32    182           2     38
2         33         33    360           1    160
3         33         33    197           0    195
4         34         32    233           3    295
5         34         32    176           0    342
6         34         33    101           0    139
> comp(fname, npairs=1000, max.cuts=max.cuts, pseudo=TRUE, spacer=0, sizes=c(500, 500))
  anchor1.id anchor2.id length orientation insert
1         31         31    572           0    186
2         31         31    332           2    188
3         32         31    159           1    159
4         32         31    147           2    873
5         32         31    429           1    429
6         32         31    596           1    596
> 
> # Checking what happens when I add more or less chromosomes 
> 
> max.cuts<-c(chrA=20L, chrB=10L)
> comp(fname, npairs=20, max.cuts=max.cuts, spacer=0, sizes=c(100, 100), extras="chrX") # should work
  anchor1.id anchor2.id length orientation insert
1          4          3     99           3     79
2         10          6    145           0    355
3         13          7     93           0    541
4         17          7     98           2   1022
5         18         10    168           0    806
6         19          6    123           1   1323
> comp(fname, npairs=20, max.cuts=max.cuts, spacer=0, sizes=c(100, 100), extras="chrX", pseudo=TRUE)
  anchor1.id anchor2.id length orientation insert
1         15         12    111           3    309
> try({
+     comp(fname, npairs=20, max.cuts=max.cuts, spacer=0, sizes=c(100, 100), extras=-1L) # should be okay
+ })
Error in preparePairs(out, param, tmpdir, output.dir = file.path(dir,  : 
  missing chromosomes in cut site list
> try({
+     comp(fname, npairs=20, max.cuts=max.cuts, spacer=0, sizes=c(100, 100), extras=-1L, pseudo=TRUE)
+ })
Error in prepPseudoPairs(out, param, tmpdir, output.dir = file.path(dir,  : 
  missing chromosomes in cut site list
> 
> ###################################################################################################
> # Trying to do simulations with chimeras is hellishly complicated, so we're just going to settle for 
> # consideration of chimeras with a fixed example.
> 
> hic.file<-system.file("exdata", "hic_sort.bam", package="diffHic")
> break.file<-system.file("exdata", "cuts.rds", package="diffHic")
> cuts<-readRDS(break.file)
> param <- pairParam(cuts)
> tmpdir<-file.path(dir, "gunk")
> cntdir<-file.path(dir, "gunkcount")
> 
> # Check out generator.R in inst/exdata for cross-referencing to names. 
> # In order of appearance in printfun, all mapped read pairs are (for
> # each data.frame in the list):
> 
> named <- list(c("chimeric.invalid.5", "good.1", "good.2", "good.3", "chimeric.invalid.4", "good.4", "chimeric.invalid.6", "other.1"),
+ 		c("good.8", "good.5", "chimeric.good.4", "chimeric.good.5", "chimeric.good.1", "chimeric.invalid.2", "chimeric.invalid.1", "chimeric.invalid.3", "chimeric.invalid.7", "chimeric.good.2"),
+ 		c("good.7", "good.6", "chimeric.good.3", "other.2"))
> 
> # We also have 3 unmapped reads, 3 dangling ends, 2 self-circles, 2 singletons.
> # For chimeras, all have mapped 5' and 3' ends, 7 of which are invalid.
> 	
> preparePairs(hic.file, param, tmpdir, dedup=FALSE)
$pairs
   total   marked filtered   mapped 
      30        7        3       27 

$same.id
   dangling self.circle 
          3           2 

$singles
[1] 2

$chimeras
  total  mapped   multi invalid 
     12      12      12       7 

> 
> printfun<-function(dir, named=NULL) {
+ 	output<-list()
+ 	ix <- 1L
+ 	indices <- suppressWarnings(diffHic:::.loadIndices(tmpdir))
+ 	for (ax in names(indices)) {
+ 		if (is.null(output[[ax]])) { output[[ax]]<-list() }
+ 		for (tx in names(indices[[ax]])) {
+ 			extracted <- h5read(dir, file.path(ax, tx))
+ 			processed <- diffHic:::.getStats(extracted, ax==tx, cuts)
+ 			output[[ax]][[tx]] <- data.frame(anchor1.id=extracted$anchor1.id, anchor2.id=extracted$anchor2.id,
+ 				length=processed$length, orientation=processed$orientation, insert=processed$insert)
+ 			if (!is.null(named[[ix]])) { rownames(output[[ax]][[tx]])<-named[[ix]] }
+ 			ix <- ix + 1L
+ 		}
+ 	}
+ 	return(output)
+ }
> printfun(tmpdir, named=named)
$chrA
$chrA$chrA
                   anchor1.id anchor2.id length orientation insert
chimeric.invalid.5          2          1     40           1     40
good.1                      2          1     80           1     80
good.2                      2          1     60           2     54
good.3                      4          1     40           3    160
chimeric.invalid.4          4          2     20           1     66
good.4                      4          2     80           0    114
chimeric.invalid.6          4          3     10           1     10
other.1                     4          4     65           0     35


$chrB
$chrB$chrA
                   anchor1.id anchor2.id length orientation insert
good.8                      5          2     10           2     NA
good.5                      5          3     30           2     NA
chimeric.good.4             5          4     30           2     NA
chimeric.good.5             5          4     25           0     NA
chimeric.good.1             6          1     35           0     NA
chimeric.invalid.2          6          2     10           1     NA
chimeric.invalid.1          6          3     10           1     NA
chimeric.invalid.3          6          3     20           3     NA
chimeric.invalid.7          6          3     15           3     NA
chimeric.good.2             7          3     20           1     NA

$chrB$chrB
                anchor1.id anchor2.id length orientation insert
good.7                   6          5     25           2     64
good.6                   7          5     35           3     84
chimeric.good.3          7          6     10           1     10
other.2                  7          7     30           2     13


> 
> # Alright, so once duplicates are removed, we lose:
> #  	self.1 (mapped/self.circles -> marked)
> #   other.1 (mapped/other -> marked)	
> #   dangling.1 (mapped/dangling -> marked)
> #   chimeric.good.2 (mapped/chimeric$mapped/multi -> marked)
> #	chimeric.invalid.1 (mapped/chimeric$mapped/multi/invalid -> marked)
> #   chimeric.invalid.4 (--chimeric$multi/invalid)
> #	chimeric.good.4 (mapped/chimeric$mapped/multi -> marked)
> #	chimeric.good.5 (mapped/chimeric$mapped/multi -> marked)
> #
> # So, a gain of +7 to marked, a loss of -7 to mapped, a loss of -1 to each of
> # dangling and self.circles, a loss of -4 to chimeric$mapped, -5 to
> # chimeric$multi and -2 to chimeric$invalid. 
> #
> # Note that this will be considered the reference to which all downstream
> # tests are compared, as dedup=FALSE is the default setting.
> 
> tmpdir2<-file.path(dir, "gunk2")
> preparePairs(hic.file, param, tmpdir2)
$pairs
   total   marked filtered   mapped 
      30        7        3       20 

$same.id
   dangling self.circle 
          2           1 

$singles
[1] 2

$chimeras
  total  mapped   multi invalid 
     12       8       7       5 

> named <- list(c("chimeric.invalid.5", "good.1", "good.2", "good.3", "chimeric.invalid.4", "good.4", "chimeric.invalid.6"),
+ 	c("good.8", "good.5", "chimeric.good.1", "chimeric.invalid.2", "chimeric.invalid.3", "chimeric.invalid.7"),
+ 	c("good.7", "good.6", "chimeric.good.3", "other.2"))
> printfun(tmpdir2, named=named)
$chrA
$chrA$chrA
                   anchor1.id anchor2.id length orientation insert
chimeric.invalid.5          2          1     40           1     40
good.1                      2          1     80           1     80
good.2                      2          1     60           2     54
good.3                      4          1     40           3    160
chimeric.invalid.4          4          2     20           1     66
good.4                      4          2     80           0    114
chimeric.invalid.6          4          3     10           1     10


$chrB
$chrB$chrA
                   anchor1.id anchor2.id length orientation insert
good.8                      5          2     10           2     NA
good.5                      5          3     30           2     NA
chimeric.good.1             6          1     35           0     NA
chimeric.invalid.2          6          2     10           1     NA
chimeric.invalid.3          6          3     20           3     NA
chimeric.invalid.7          6          3     15           3     NA

$chrB$chrB
                anchor1.id anchor2.id length orientation insert
good.7                   6          5     25           2     64
good.6                   7          5     35           3     84
chimeric.good.3          7          6     10           1     10
other.2                  7          7     30           2     13


> 
> # Once invalid chimeras are removed, we see a loss of all rows corresponding to
> # invalid chimeras in printfun. No change in the statistics should be observed.
> # Note that chimeric.invalid.4 is still okay as ther invalid component is removed
> # by duplicate removal (for some reason; that shouldn't happen in real data).
> 
> preparePairs(hic.file, param, tmpdir2, ichim=FALSE)
$pairs
   total   marked filtered   mapped 
      30        7        3       20 

$same.id
   dangling self.circle 
          2           1 

$singles
[1] 2

$chimeras
  total  mapped   multi invalid 
     12       8       7       5 

> named <- list(c("good.1", "good.2", "good.3", "chimeric.invalid.4", "good.4"),
+ 	c("good.8", "good.5", "chimeric.good.1"),
+ 	c("good.7", "good.6", "chimeric.good.3", "other.2"))
> printfun(tmpdir2, named=named)
$chrA
$chrA$chrA
                   anchor1.id anchor2.id length orientation insert
good.1                      2          1     80           1     80
good.2                      2          1     60           2     54
good.3                      4          1     40           3    160
chimeric.invalid.4          4          2     20           1     66
good.4                      4          2     80           0    114


$chrB
$chrB$chrA
                anchor1.id anchor2.id length orientation insert
good.8                   5          2     10           2     NA
good.5                   5          3     30           2     NA
chimeric.good.1          6          1     35           0     NA

$chrB$chrB
                anchor1.id anchor2.id length orientation insert
good.7                   6          5     25           2     64
good.6                   7          5     35           3     84
chimeric.good.3          7          6     10           1     10
other.2                  7          7     30           2     13


> 
> # Throwing out those with poor mapping quality. We lose:
> #   good.1 (mapped -> filtered)
> #   good.3 (mapped -> filtered)
> #   dangling.2 (mapped/dangling -> filtered)
> #   dangling.3 (mapped/dangling -> filtered)
> #   chimeric.good.1 (--chimeric$multi)
> #	chimeric.invalid.2 (mapped/chimeric$mapped/multi/invalid -> filtered)
> #   chimeric.invalid.3 (--chimeric$multi/invalid)
> # 	chimeric.invalid.6 (mapped/chimeric$mapped/multi/invalid -> filtered)
> #
> # So, a gain of +6 for filtered, a loss of -6 for mapped, a loss of -2
> # for dangling, a loss of -2 for chimeric$mapped, -4 for chimeric$multi
> # and -3 for chimeric$invalid. For printfun, we see:
> # 	A/A = chimeric.invalid.5, good.2, chimeric.invalid.4, good.4
> #	B/A = good.8, good.5, chimeric.invalid.7
> # 	B/B = good.7, good.6, chimeric.good.
> 
> preparePairs(hic.file, param, tmpdir2, minq=100)
$pairs
   total   marked filtered   mapped 
      30        7        9       14 

$same.id
   dangling self.circle 
          0           1 

$singles
[1] 2

$chimeras
  total  mapped   multi invalid 
     12       6       3       2 

> named <- list(c("chimeric.invalid.5", "good.2", "chimeric.invalid.4", "good.4"),
+ 	c("good.8", "good.5", "chimeric.good.1", "chimeric.invalid.3", "chimeric.invalid.7"),
+ 	c("good.7", "good.6", "chimeric.good.3", "other.2"))
> printfun(tmpdir2, named=named)
$chrA
$chrA$chrA
                   anchor1.id anchor2.id length orientation insert
chimeric.invalid.5          2          1     40           1     40
good.2                      2          1     60           2     54
chimeric.invalid.4          4          2     20           1     66
good.4                      4          2     80           0    114


$chrB
$chrB$chrA
                   anchor1.id anchor2.id length orientation insert
good.8                      5          2     10           2     NA
good.5                      5          3     30           2     NA
chimeric.good.1             6          1     35           0     NA
chimeric.invalid.3          6          3     20           3     NA
chimeric.invalid.7          6          3     15           3     NA

$chrB$chrB
                anchor1.id anchor2.id length orientation insert
good.7                   6          5     25           2     64
good.6                   7          5     35           3     84
chimeric.good.3          7          6     10           1     10
other.2                  7          7     30           2     13


> 
> # Defining invalid chimeras based on distance instead of fragment ID. chimeric.good.1
> # becomes an invalid chimera, as the distance between the 3' segment and the mate is
> # 30 bp. This results in a +1 increase for invalid.chim.
> 
> preparePairs(hic.file, param, tmpdir2, chim.dist=20, ichim=FALSE)
$pairs
   total   marked filtered   mapped 
      30        7        3       20 

$same.id
   dangling self.circle 
          2           1 

$singles
[1] 2

$chimeras
  total  mapped   multi invalid 
     12       8       7       6 

> named <- list(c("good.1", "good.2", "good.3", "chimeric.invalid.4", "good.4"),
+ 	c("good.8", "good.5"),
+ 	c("good.7", "good.6", "chimeric.good.3", "other.2"))
> printfun(tmpdir2, named=named)
$chrA
$chrA$chrA
                   anchor1.id anchor2.id length orientation insert
good.1                      2          1     80           1     80
good.2                      2          1     60           2     54
good.3                      4          1     40           3    160
chimeric.invalid.4          4          2     20           1     66
good.4                      4          2     80           0    114


$chrB
$chrB$chrA
       anchor1.id anchor2.id length orientation insert
good.8          5          2     10           2     NA
good.5          5          3     30           2     NA

$chrB$chrB
                anchor1.id anchor2.id length orientation insert
good.7                   6          5     25           2     64
good.6                   7          5     35           3     84
chimeric.good.3          7          6     10           1     10
other.2                  7          7     30           2     13


> 
> # chimeric.invalid.6 now becomes a valid chimera, as each pair of 5' end and 3' mate end
> # is now a proper pair (inward-facing and less than chim.dist). -1 for invalid.chim.
> 
> preparePairs(hic.file, param, tmpdir2, chim.dist=2000, ichim=FALSE)
$pairs
   total   marked filtered   mapped 
      30        7        3       20 

$same.id
   dangling self.circle 
          2           1 

$singles
[1] 2

$chimeras
  total  mapped   multi invalid 
     12       8       7       4 

> named <- list(c("good.1", "good.2", "good.3", "chimeric.invalid.4", "good.4", "chimeric.invalid.6"),
+ 	c("good.8", "good.5", "chimeric.good.1"),
+ 	c("good.7", "good.6", "chimeric.good.3", "other.2"))
> printfun(tmpdir2, named=named)
$chrA
$chrA$chrA
                   anchor1.id anchor2.id length orientation insert
good.1                      2          1     80           1     80
good.2                      2          1     60           2     54
good.3                      4          1     40           3    160
chimeric.invalid.4          4          2     20           1     66
good.4                      4          2     80           0    114
chimeric.invalid.6          4          3     10           1     10


$chrB
$chrB$chrA
                anchor1.id anchor2.id length orientation insert
good.8                   5          2     10           2     NA
good.5                   5          3     30           2     NA
chimeric.good.1          6          1     35           0     NA

$chrB$chrB
                anchor1.id anchor2.id length orientation insert
good.7                   6          5     25           2     64
good.6                   7          5     35           3     84
chimeric.good.3          7          6     10           1     10
other.2                  7          7     30           2     13


> 
> ###################################################################################################
> # This tests what happens with chimeras where one of the segments is unmapped. This requires some
> # care because unmapped reads don't get CIGAR strings, which makes diagnosing 5' behaviour difficult.
> 
> generator <- function(cig1, cig2, cig3, cig4) {
+     mapped <- "chrA 100"
+     unmapped <- "* 0"
+     out <- sprintf("@HD VN:1.3  SO:queryname
+ @SQ SN:chrA LN:200
+ x1 %i %s 200 %s * 0 0 NNNNN hhhhh
+ x1 %i %s 200 %s * 0 0 NNNNN hhhhh
+ x1 %i %s 200 %s * 0 0 NNNNN hhhhh
+ x1 %i %s 200 %s * 0 0 NNNNN hhhhh",
+     1+64 +ifelse(cig1=="*", 4, 0),     ifelse(cig1!="*", mapped, unmapped), cig1,
+     1+64 +ifelse(cig2=="*", 4, 0)+256, ifelse(cig2!="*", mapped, unmapped), cig2,
+     1+128+ifelse(cig3=="*", 4, 0),     ifelse(cig3!="*", mapped, unmapped), cig3,
+     1+128+ifelse(cig4=="*", 4, 0)+256, ifelse(cig4!="*", mapped, unmapped), cig4)
+     return(gsub(" +", "\t", out))
+ }
> fout <- file.path(dir, "umap.sam")
> 
> # None of these should show up as a pair.
> for (scenario in list(list("*", "*", "*", "*"),
+                       list("5M5H", "*", "*", "*"),
+                       list("*", "*", "5M5H", "*"),
+                       list("*", "*", "*", "5H5M"),
+                       list("*", "5H5M", "5M5H", "*"),
+                       list("5M5H", "*", "*", "5H5M"))) {
+     writeLines(do.call(generator, scenario), con=fout)
+     sout <- Rsamtools::asBam(fout, file.path(dir, "umap"), overwrite=TRUE)
+     x <- preparePairs(sout, param=pairParam(GRanges("chrA", IRanges(c(1, 71), c(70, 200)))), file=file.path(dir, "whee.h5"))
+     stopifnot(x$pairs[["total"]]==1L)
+     stopifnot(x$pairs[["filtered"]]==1L)
+     stopifnot(x$chimeras[["total"]]==1L)
+     stopifnot(x$chimeras[["mapped"]]==0L)
+ }
> 
> # All of these should show up as a pair.
> writeLines(generator("5M5H", "*", "5M5H", "*"), con=fout)
> sout <- Rsamtools::asBam(fout, file.path(dir, "umap"), overwrite=TRUE)
> x <- preparePairs(sout, param=pairParam(GRanges("chrA", IRanges(c(1, 71), c(70, 200)))), file=file.path(dir, "whee.h5"))
> stopifnot(x$pairs[["total"]]==1L)
> stopifnot(x$pairs[["mapped"]]==1L)
> stopifnot(x$chimeras[["total"]]==1L)
> stopifnot(x$chimeras[["mapped"]]==1L)
> stopifnot(x$chimeras[["multi"]]==0L)
> 
> for (scenario in list(list("5M5H", "5H5M", "5M5H", "*"),
+                       list("5M5H", "*", "5M5H", "5H5M"),
+                       list("5M5H", "5H5M", "5M5H", "5H5M"))) {
+     writeLines(do.call(generator, scenario), con=fout)
+     sout <- Rsamtools::asBam(fout, file.path(dir, "umap"), overwrite=TRUE)
+     x <- preparePairs(sout, param=pairParam(GRanges("chrA", IRanges(c(1, 71), c(70, 200)))), file=file.path(dir, "whee.h5"))
+     stopifnot(x$pairs[["total"]]==1L)
+     stopifnot(x$pairs[["mapped"]]==1L)
+     stopifnot(x$chimeras[["total"]]==1L)
+     stopifnot(x$chimeras[["mapped"]]==1L)
+     stopifnot(x$chimeras[["multi"]]==1L)
+ }
> 
> ###################################################################################################
> 
> unlink(dir, recursive=TRUE) # Cleaning up
> 
> ###################################################################################################
> 
> 
> proc.time()
   user  system elapsed 
 15.542   0.704  16.284 
